---
layout: mypost
title:  "前端面试——Vue3 真题"
date:   2021-03-27 15:07:24 +0800
categories: ['前端', '面试', 'Vue', '真题', ]
---

## Vue3 比 Vue2 有什么优势
- **性能更好**
- 体积更小
- 更好的TS支持
- 更好的代码组织
- 更好的逻辑抽离
- 更多的新功能

## Vue3 生命周期
### Options API 生命周期
- beforeDestroy -> beforeUnmount
- destroyed -> unmounted
- 其他沿用Vue2的生命周期

### Composition Api生命周期
- setup
- onBeforeMount
- onBeforeMounted
- onBeforeUpdate
- onUpdated
- onBeforeUnmount
- onUnmounted

## Composition API 和 Options API 对比
### Composition API 带来了什么
- 更好的代码组织
- 更好的逻辑复用
- 更好的类型推导
### 如何选择
- 不建议共用，会引起混乱
- 小型项目、业务逻辑简单，用Options API
- 中大型项目、逻辑复杂，用Composition API
### 不要误解Composition API
- 高阶技巧
- 为解决复杂逻辑而设计
- 类似于React Hooks在React中的地位

## ref toRef toRefs
### ref (生成一个响应式的变量)
- 生成值类型的响应式数据
- 可用于模板和reactive
- 通过.value修改值
```html
<template>
    <p>ref demo {{ageRef}} {{state.name}}</p>
</template>

<script>
import { ref, reactive } from 'vue'

export default {
    name: 'Ref',
    setup() {
        const ageRef = ref(20) // 值类型 响应式
        const nameRef = ref('双越')

        const state = reactive({
            name: nameRef
        })

        setTimeout(() => {
            console.log('ageRef', ageRef.value)

            ageRef.value = 25 // .value 修改值
            nameRef.value = '双越A'
        }, 1500);

        return {
            ageRef,
            state
        }
    }
}
</script>
```

```html
<template>
    <p ref="elemRef">我是一行文字</p>
</template>

<script>
import { ref, onMounted } from 'vue'

export default {
    name: 'RefTemplate',
    setup() {
        const elemRef = ref(null)

        onMounted(() => {
            console.log('ref template', elemRef.value.innerHTML, elemRef.value)
        })

        return {
            elemRef
        }
    }
}
</script>
```

### toRef (将响应式对象中的某个属性转换为响应式)
- 针对一个响应式对象(reactive封装)的prop
- 创建一个ref,具有响应式
- 两者保持引用关系
```html
<template>
    <p>toRef demo - {{ageRef}} - {{state.name}} {{state.age}}</p>
</template>

<script>
import { ref, toRef, reactive } from 'vue'

export default {
    name: 'ToRef',
    setup() {
        const state = reactive({
            age: 20,
            name: '双越'
        })

        const ageRef = toRef(state, 'age')

        setTimeout(() => {
            state.age = 25
        }, 1500)

        setTimeout(() => {
            ageRef.value = 30 // .value 修改值
        }, 3000)

        return {
            state,
            ageRef
        }
    }
}
</script>
```

### toRefs
- 将响应式对象(reactive封装)转换为普通对象
- 对象的每个prop都是对应的ref
- 两者保持引用关系
- 可以在不破坏对象属性的响应式的情况下解构出对应的属性值
```HTML
<template>
    <p>toRefs demo {{age}} {{name}}</p>
</template>

<script>
import { ref, toRef, toRefs, reactive } from 'vue'

export default {
    name: 'ToRefs',
    setup() {
        const state = reactive({
            age: 20,
            name: '双越'
        })

        const stateAsRefs = toRefs(state) // 将响应式对象，变成普通对象

        setTimeout(() => {
            state.age = 25
        }, 1500)

        return stateAsRefs
    }
}
</script>
```


### 最佳使用方式(将响应式对象中所有属性转换为响应式)
- 用reactive做对象的响应式，用ref做值类型响应式
- setup中返回toRefs(state),或者toRef(state, 'xxx')
- ref的变量命名用xxxRef
- 合成函数返回响应式对象时，使用toRefs

### 进阶，深入理解
#### 为何需要ref
- 返回值类型，会丢失响应式
- 如在setup,computed,合成函数，都有可能返回值类型
- Vue如果不定义ref,用户将自造ref,反而混乱 

#### 为何需要.value
- ref是一个对象（不丢失响应式），value存储值
- 通过.value属性的get和set实现响应式
- 用于模板、reactive时（会经过vue自身的编译，vue可自动识别转换成.value），不需要.value,其他情况都需要

#### 为何需要toRef toRefs
- 初衷：不丢失响应式的情况下，把对象数据分解/扩散
- 前提：针对响应式对象(reactive封装)，非普通对象
- 注意：不是创造响应式，而是延续响应式

## Vue3升级了哪些重要的功能
- createAPP——vue初始化方法
- emits属性——子组件抛出事件新增配置
- 生命周期——销毁更改为unmount
- 多事件——元素可以绑定多个事件
- Fragement——片元，模板中可以写多个元素
- 移除.Sync
- 异步组件的写法——新增异步组件引入的方法
- 移除filter
- Teleport——传送，挂载全局组件到body
- Suspense——延迟，利用插槽实现了组件异步加载的loading状态
- Composition API
```
- reactive
- ref相关
- readonly
- watch和watchEffect
- setup
- 生命周期钩子函数
```

## Composition API 如何实现代码逻辑复用
- 抽离逻辑代码到一个函数
- 函数命名约定为useXXX格式
- 在setup中引用useXXX函数

## Vue3如何实现响应式
### Object.defineProperty的缺点
- 深度监听需要一次性递归
- 无法监听新增/删除属性（需要使用Vue.set Vue.delete）
- 无法监听原生数组，需要特殊处理（定义新的数组原型并扩展数组方法）

### Proxy实现响应式
```JS
// const data = {
//     age: 20,
//     name: 'xxx',
// }

const data = ['a', 'b', 'c'];

const proxyData = new Proxy(data, {
    get(target, key, receiver) {
        const result = Reflect.get(target, key, receiver);

        // 只打印本身的，非原型上的属性
        const ownKeys = Reflect.ownKeys(target);
        if(ownKeys.includes(key)) {
            console.log('get', key);
        }
        return result; //返回结果
    },
    set(target, key, val, receiver) {
        // 重复的数据不处理
        const oldVal = target[key];
        if(val === oldVal) {
            return true;
        }

        const result = Reflect.set(target, key, val, receiver);
        console.log('set', key, val);
        console.log('result', result);
        return result; //是否设置成功
    },
    deleteProperty(target, key) {
        const result = Reflect.deleteProperty(target, key);
        console.log('delete property', key);
        console.log('result', result);
        return result; //是否删除成功
    }
})

// proxyData.age = 23;

proxyData.push('d');
```

Reflect作用
- 和Proxy能力一一对应
- 规范化、标准化、函数式
- 代替Object上的工具函数

## watch 和 watchEffect 的区别

## setup 中如何获取组件实例

## Vue3 为何比 Vue2 快

## Vite 是什么

## Compositon API 和 React Hooks 的对比